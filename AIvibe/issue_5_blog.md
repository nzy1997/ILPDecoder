# AI Vibe Development Retrospective: ILPDecoder

This post is based on `AIvibe/early_propmts.md` and `AIvibe/history.jsonl`, and
reviews the ILPDecoder development process by phase. Each phase lists the
key prompts and explains what those prompts were trying to drive, so the
workflow can be reproduced.

## 1) Exploration and Benchmarking (Kickoff)

The goal of this phase was to survey the ecosystem, set direction, and define
the minimal viable scope.

**Prompts (with intent)**
- Investigate how to handle integer programming problems in Python.  
  Intent: identify common ILP/MIP tooling and modeling patterns in Python.
- I am quite familiar with the relationship between JuMP and solvers like SCIP and HiGHS in Julia. Is there an analogous setup in Python?  
  Intent: find a Python equivalent of the JuMP/MOI layering model.
- Are there any Python packages for integer programming applied to QEC (quantum error correction)?  
  Intent: check for existing projects to avoid duplicating effort.
- I want to write a package that solves QEC decoding problems using integer programming. The intended functionality includes:  
  - Similar to PyMatching, it should be able to directly decode from a parity check matrix, or decode from a detector error model generated by Stim.  
    Intent: define the two main input frontends (H matrices and DEMs).
  - A modular solver backend that allows users to choose and configure solvers according to their needs, similar to JuMP.  
    Intent: make solver pluggability a core requirement.
- Please help me design a development plan.  
  Intent: translate needs into an actionable plan.

## 2) Repository Skeleton and Public Narrative

Once direction was set, the next step was to create the overall repo structure
and produce a clear README for new users.

**Prompts (with intent)**
- Generate this package according to the plan.  
  Intent: scaffold the project according to the plan.
- update the README.md to introduce this package properly. remove the julia and jump disscussion  
  Intent: keep the intro focused on Python/ILP, not Julia.
- Be critical. Judge what is needed to do before publish this package  
  Intent: identify gaps needed before release.

## 3) DEM Support Boundaries and Model Assumptions

This phase clarified Stim DEM syntax handling, flattening strategy, `^`
semantics, defaults, and probability conventions.

**Prompts (with intent)**
- Only `error(p)` lines are parsed... why the dem contains a `detector`?  
  Intent: question metadata handling and tighten the parsing rules.
- I want to allow detector metadata instead of rejecting it...  
  Intent: shift from hard errors to ignoring metadata.
- judge 1 add an optional flatten_dem=True flag... which one is better? Don't code at this time  
  Intent: evaluate strategies before implementation.
- I want a stronger “just works” UX, set flatten_dem=True by default...  
  Intent: pick defaults that improve out-of-box behavior.
- support ^ and did not split the dem with it just ignore it. Document other unsupport cases.  
  Intent: define how `^` is treated and document unsupported cases.
- Should p>0.5 be rejected or supported with negative weights? rejected  
  Intent: lock in probability and weight conventions.

## 4) CI, Coverage, and Release Readiness

This phase focused on getting CI, build checks, and coverage to a publishable
state.

**Prompts (with intent)**
- Fix: Add CI to run tests and verify build artifacts (python -m build).  
  Intent: establish baseline CI and build validation.
- add Code coverage so that we can see the code coverage number on github webpage  
  Intent: integrate Codecov for visible quality metrics.
- add more tests. I want the coverage above 95%  
  Intent: raise coverage with additional tests.
- Great! the codecov is 94% now. add more tests to approach 100%  
  Intent: push coverage higher and uncover missing branches.
- The tests are failing fix!  
  Intent: keep CI green.
- Why I can't see the codcov change before merge  
  Intent: investigate Codecov reporting/merge checks.

## 5) Benchmarks and Correctness Comparisons

This phase built benchmarks, compared against MWPM/BPOSD, investigated an
unexpected LER gap, and fixed the underlying issue.

**Prompts (with intent)**
- add a benchmark example... compare with BPOSD and MWPM  
  Intent: establish baseline comparisons.
- run it for me and summarize the result in README.md  
  Intent: record results in a reproducible way.
- use --shots 10000 ... update the res in README.md  
  Intent: reduce variance and update results.
- it is weird that the Logical Error Rate for ILPDecoder is higher than MWPM. Analyse why?  
  Intent: trigger a root-cause analysis.
- fix the bug and rerun the tests and benchmark  
  Intent: verify fixes with tests and benchmarks.
- add code capacity benchmark... use higher --noise 0.08  
  Intent: broaden benchmarks with a different noise model.

## 6) Solver System and Performance Optimization

This phase targeted speed and extensibility: profiling first, then adding more
solvers and direct backends.

**Performance prompts (with intent)**
- Profile the exitsing decoder first use the default solver...  
  Intent: locate bottlenecks.
- is there any imporvementon the time performance we can do in this package  
  Intent: identify likely optimizations.

**Multi-solver / direct backend prompts (with intent)**
- Add more ILP solver and compare their performance... skip CPLEX  
  Intent: expand solver coverage and compare behavior.
- Use a faster backend directly... estimate how much time we will save  
  Intent: evaluate potential gains from direct APIs.
- prototype a direct HiGHS backend and re-profile  
  Intent: implement and validate the direct backend.
- implement Gurobi solver like highs but need to install by ilpdecoder[gurobi]  
  Intent: add a direct Gurobi option with a dedicated extra.
- compare direct HiGHS backend, direct Gurobi backend, Pyomo backend...  
  Intent: quantify tradeoffs across backends.
- Make highs as the default solver and make pyomo as a extra package...  
  Intent: keep the default path simple while preserving flexibility.
- CI split: test both minimal install (HiGHS only) and .[pyomo]  
  Intent: prevent regressions in minimal vs extra installs.

## 7) Documentation and Site Publishing

After core functionality stabilized, the focus shifted to docs and a public
site.

**Prompts (with intent)**
- add documentation for this repo which type of file do you recommend  
  Intent: pick a docs format and tooling.
- I want a published site  
  Intent: require a hosted docs site.
- set up 1  
  Intent: choose MkDocs + GitHub Pages.
- Preview locally for me  
  Intent: validate docs locally.
- move ## Mathematical Formulation part to a markdown file in doc/  
  Intent: migrate math details into docs.
- move solver part from Readme to doc, write more math, explain examples  
  Intent: keep README concise, push detail into docs.

## Summary

By breaking the development into phases and anchoring each phase with clear
prompts, the full pipeline from requirements to release becomes reproducible:
requirements → design → implementation → testing → evaluation → docs → publish.
Reusing these prompts per phase yields a consistent, high-quality outcome.
